{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1046\deflangfe1046{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\fswiss\fprq2\fcharset0 Calibri;}{\f2\fnil\fcharset2 Symbol;}}
{\*\generator Riched20 10.0.22621}{\*\mmathPr\mnaryLim0\mdispDef1\mwrapIndent1440 }\viewkind4\uc1 
\pard\keep\keepn\nowidctlpar\sb240\sl259\slmult0\qc\b\f0\fs48\lang22 Trabalho Pr\'e1tico 1 \line 8-Puzzle\par

\pard\nowidctlpar\sa160\sl259\slmult0\qc\fs32 Introdu\'e7\'e3o \'e0 Intelig\'eancia Artificial\ul\par
\ulnone\fs28 Louren\'e7o Ferreira Monteiro Dias Montenegro - 2020006744\par
\b0\fs24 Universidade Federal de Minas Gerais (UFMG)\par
Belo Horizonte \endash  MG \endash  Brasil\fs20\par
\par

\pard 
{\pntext\f0 1.\tab}{\*\pn\pnlvlbody\pnf0\pnindent0\pnstart1\pndec{\pntxta.}}
\nowidctlpar\fi-360\li360\sa160\sl259\slmult0\b\fs32 Estrutura de dados e Modelagem\par

\pard\nowidctlpar\sa160\sl259\slmult0\b0\fs24 Com o objetivo de representar cada n\'f3 das \'e1rvores de busca dos algoritmos, a classe \lquote Node\rquote  foi criada e possui os atributos: board, children, level, cost.\par

\pard{\pntext\f2\'B7\tab}{\*\pn\pnlvlblt\pnf2\pnindent0{\pntxtb\'B7}}\nowidctlpar\fi-360\li720\sa160\sl259\slmult0 Board: esse atributo \'e9 a representa\'e7\'e3o do tabuleiro do 8-puzzle, uma matriz 3x3 (lista de listas)\par
{\pntext\f2\'B7\tab}Children: \'e9 a lista de n\'f3s filhos daquele n\'f3, possuem o tipo Node\par
{\pntext\f2\'B7\tab}Level: representa o n\'edvel da \'e1rvore ou o n\'famero de jogadas que foram necess\'e1rias para chegar naquele n\'f3/estado do tabuleiro\par
{\pntext\f2\'B7\tab}Cost: para os algoritmos que utilizam esse par\'e2metro ele \'e9 inicializado como 0 e a fun\'e7\'e3o setCost(self, cost) define o custo associado \'e0quele n\'f3 no algoritmo\par
{\pntext\f2\'B7\tab}Parent: tem valor padr\'e3o como None, aponta para o n\'f3 pai daquele n\'f3\par

\pard\nowidctlpar\sa160\sl259\slmult0 Para auxiliar na execu\'e7\'e3o dos algoritmos de busca, no arquivo "Tree.py" os m\'e9todos da classe Node a seguir foram criados:\par

\pard{\pntext\f2\'B7\tab}{\*\pn\pnlvlblt\pnf2\pnindent0{\pntxtb\'B7}}\nowidctlpar\fi-360\li720\sa160\sl259\slmult0 printBoard(self): Imprime o tabuleiro do n\'f3\par
{\pntext\f2\'B7\tab}printPath(self): Imprime o caminho desde o n\'f3 inicial\par
{\pntext\f2\'B7\tab}setCost(self, cost): Define o custo atrelado \'e0quele n\'f3 (se o algoritmo utilizado tiver um custo relacionado)\par
{\pntext\f2\'B7\tab}getEmptyPosition(self): Retorna a posi\'e7\'e3o do quadrado vazio\par
{\pntext\f2\'B7\tab}movePieceUp: Retorna um novo objeto Node com uma altera\'e7\'e3o no tabuleiro, em que a pe\'e7a que est\'e1 abaixo do espa\'e7o vazio \'e9 trocada com a pe\'e7a de espa\'e7o vazio\par
{\pntext\f2\'B7\tab}movePieceDown: Retorna um novo objeto Node com uma altera\'e7\'e3o no tabuleiro, em que a pe\'e7a que est\'e1 acima do espa\'e7o vazio \'e9 trocada com a pe\'e7a de espa\'e7o vazio\par
{\pntext\f2\'B7\tab}movePieceLeft: Retorna um novo objeto Node com uma altera\'e7\'e3o no tabuleiro, em que a pe\'e7a que est\'e1 a direita do espa\'e7o vazio \'e9 trocada com a pe\'e7a de espa\'e7o vazio\par
{\pntext\f2\'B7\tab}movePieceRight: Retorna um novo objeto Node com uma altera\'e7\'e3o no tabuleiro, em que a pe\'e7a que est\'e1 a esquerda do espa\'e7o vazio \'e9 trocada com a pe\'e7a de espa\'e7o vazio\par
{\pntext\f2\'B7\tab}isSolution(self): verifica se o estado do n\'f3 \'e9 solu\'e7\'e3o do problema\par
{\pntext\f2\'B7\tab}generateChildren(self): gera as poss\'edveis pr\'f3ximas jogadas a partir do tabuleiro do n\'f3 e as adiciona \'e0 lista children.\b\fs32\par

\pard\nowidctlpar\li360\sa160\sl259\slmult0\b0\fs24  \b\fs32\par

\pard\nowidctlpar\sa160\sl259\slmult0 2. Algoritmos de busca\b0\par
\fs24 Para cada algoritmo de busca proposto, uma (ou mais) fun\'e7\'e3o foi criada para execu\'e7\'e3o da busca a partir do n\'f3 inicial. A seguir, irei discorrer sobre cada um dos algoritmos implementados. Todos os algoritmos tem como par\'e2metro de entrada o primeiro n\'f3/estado do jogo da classe Node.\par
\b\fs32 Breadth-first search\b0\fs24\par
No m\'e9todo de busca em largura h\'e1 um loop while ap\'f3s a defini\'e7\'e3o da lista de n\'f3s n\'e3o visitados (que \'e9 inicializado com o n\'f3 da entrada), vari\'e1veis de n\'edvel da solu\'e7\'e3o e n\'f3Solu\'e7\'e3o. Nesse loop while, enquanto o n\'edvel da solu\'e7\'e3o n\'e3o for definido, o algoritmo verifica se algum item da lista de n\'f3s n\'e3o visitados \'e9 uma solu\'e7\'e3o do jogo, caso algum seja encerra o loop, caso n\'e3o haja nenhum, os filhos de cada n\'f3 da lista \'e9 gerado e adicionado \'e0 lista de n\'e3o visitados, enquanto todos os n\'f3s visitados s\'e3o removidos da lista. Esse loop se repete at\'e9 que a solu\'e7\'e3o seja encontrada.\par
\b\fs32 Iterative deepening search\b0\fs24\par
No algoritmo de Aprofundamento Iterativo, a vari\'e1vel de limite \'e9 inicializada como 0. Abro um loop while, que, enquanto uma solu\'e7\'e3o n\'e3o for retornada a fun\'e7\'e3o de busca em profundidade \'e9 acionada. Se o retorno da fun\'e7\'e3o DFS for False, significa que nenhuma solu\'e7\'e3o foi encontrada at\'e9 a profundidade limite, dessa forma o limite \'e9 incrementado e passa para uma nova itera\'e7\'e3o.\par
A fun\'e7\'e3o DFS \'e9 implementada utilizando uma pilha, um loop \'e9 inicializado. Para cada n\'f3 testado que n\'e3o seja solu\'e7\'e3o, seus filhos s\'e3o adicionados no topo da pilha para serem testados nas pr\'f3ximas itera\'e7\'f5es e o n\'f3 pai \'e9 removido da pilha. \par
\b\fs32 Uniform-cost search\b0\fs24\par
No m\'e9todo de busca uniforme ou algoritmo de Dijkstra, inicializo uma fila de n\'f3s com o n\'f3 raiz e uma lista vazia de n\'f3s visitados. Enquanto a fila de prioridades n\'e3o for vazia, o primeiro n\'f3 da fila \'e9 testado, se ele n\'e3o for solu\'e7\'e3o, o n\'f3 \'e9 adicionado a lista de n\'f3s visitados, seus filhos s\'e3o adicionados no fim da fila, caso n\'e3o estejam na lista de visitados.\par
Uma observa\'e7\'e3o importante \'e9 que como o grafo do 8-puzzle possui arestas de mesmo custo, pois todos os movimentos tem o mesmo custo, n\'e3o \'e9 necess\'e1rio ordenar a lista de prioridade de acordo com o custo dos caminhos. Caso cada movimento tivesse um custo associado espec\'edfico, ap\'f3s adicionar novos n\'f3s na lista de prioridades, ela deveria ser reordenada de forma que, o primeiro elemento da fila tivesse o menor custo e o \'faltimo valor tivesse o maior custo.\par
\b\fs32 A* search\b0\fs24\par
Para implementar o algoritmo A*, a heur\'edstica escolhida foi a de n\'famero de pe\'e7as fora da posi\'e7\'e3o, quanto maior o n\'famero de pe\'e7as fora da sua posi\'e7\'e3o da solu\'e7\'e3o maior ser\'e1 o custo daquele movimento. Dessa forma, uma fila de prioridades \'e9 inicializada com o n\'f3 raiz e uma fila de n\'f3s visitados vazia. Enquanto a lista de prioridades n\'e3o for vazia ou a solu\'e7\'e3o n\'e3o for encontrada, testa o primeiro elemento da fila, se ele n\'e3o for solu\'e7\'e3o, adiciona esse n\'f3 a lista de visitados e \'e9 retirado da fila de prioridades, seus filhos s\'e3o adicionados a fila e ordenados a partir da fun\'e7\'e3o:\par

\pard\nowidctlpar\sa160\sl259\slmult0\qc f(n) = h(n) + i(n)\par
h(n) \'e9 a fun\'e7\'e3o da heur\'edstica e i(n) a fun\'e7\'e3o do uniform-cost search\par

\pard\nowidctlpar\sa160\sl259\slmult0\'c9 importante notar que a fun\'e7\'e3o i(n) ter\'e1 o mesmo valor para todos os movimentos, pois o custo de todos os movimentos \'e9 uniforme.\par
\b\fs32 Greedy best-first search\b0\fs24\par
No algoritmo de busca gulosa, diferente do A* apenas a fun\'e7\'e3o heur\'edstica \'e9 utilizada para ordenar a fila de n\'f3s n\'e3o visitados, fora isso, o algoritmo funciona da mesma forma que o A*.\par
A heur\'edstica utilizada \'e9 a de dist\'e2ncia Manhattan, para cada pe\'e7a do tabuleiro, a dist\'e2ncia Manhattan entre a posi\'e7\'e3o atual e a posi\'e7\'e3o da solu\'e7\'e3o \'e9 calculada. Quanto maior a dist\'e2ncia total, menor prioridade o movimento ter\'e1 para ser explorado.\par
\b\fs32 Hill Climbing\b0\fs24\par
No m\'e9todo Hill Climbing\par
\par
\par
\b\fs32 3. An\'e1lise das heur\'edsticas\par
\b0\fs24 Para analisar as heur\'edsticas, \'e9 necess\'e1rio definir que, uma heur\'edstica admiss\'edvel \'e9 uma heur\'edstica que nunca superestima o custo da solu\'e7\'e3o \'f3tima, ou seja, nunca retorna um valor maior do que o custo real da solu\'e7\'e3o \'f3tima a partir desse estado.\par

\pard{\pntext\f2\'B7\tab}{\*\pn\pnlvlblt\pnf2\pnindent0{\pntxtb\'B7}}\nowidctlpar\fi-360\li720\sa160\sl259\slmult0\fs28 N\'famero de pe\'e7as fora de posi\'e7\'e3o da solu\'e7\'e3o\fs24\par

\pard\nowidctlpar\sa160\sl259\slmult0 Essa heur\'edstica pode ser classificada como admiss\'edvel, pois no valor m\'e1ximo da fun\'e7\'e3o heur\'edstica (custo = 8), mostra que cada pe\'e7a dever\'e1 ser movida pelo menos 1 posi\'e7\'e3o, o que \'e9 verdade caso todas as pe\'e7as estejam na posi\'e7\'e3o errada\par

\pard{\pntext\f2\'B7\tab}{\*\pn\pnlvlblt\pnf2\pnindent0{\pntxtb\'B7}}\nowidctlpar\fi-360\li720\sa160\sl259\slmult0\fs28 Dist\'e2ncia Manhattan\fs24\par

\pard\nowidctlpar\sa160\sl259\slmult0 A heur\'edstica de Manhattan, tamb\'e9m pode ser considerada como admiss\'edvel, porque cada a\'e7\'e3o movimenta cada pe\'e7a apenas um passo mais perto do objetivo. Essa heur\'edstica retorna um valor menor ou igual \'e0 dist\'e2ncia real entre o estado atual e o estado objetivo, isso ocorre pois ela s\'f3 consider movimentos horizontais e verticais.\par

\pard\nowidctlpar\sa160\sl259\slmult0\par

\pard\nowidctlpar\sa160\sl259\slmult0\par
\b\fs32 4. Testes \par
5. Conclus\'e3o\par
\par
\b0\fs24 O trabalho pr\'e1tico foi muito importante para colocar em pr\'e1tica os conhecimentos adquiridos na disciplina de Programa\'e7\'e3o de Computadores, durante o semestre. No momento da implementa\'e7\'e3o de um projeto, \'e9 poss\'edvel lidar com problemas reais relatados durante as aulas, como documenta\'e7\'e3o de c\'f3digo, problemas de l\'f3gica e de tradu\'e7\'e3o das ideias em um c\'f3digo limpo e organizado, al\'e9m de entender melhor como a linguagem Python funciona e como podemos utiliz\'e1-la para automatizar processos, como o de resolu\'e7\'e3o de sistemas de equa\'e7\'f5es triangulares.\b\fs32\par

\pard\nowidctlpar\sa200\sl276\slmult1\b0\f1\fs22\par
}
 